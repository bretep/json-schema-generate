package generate

import "text/template"

var headerTmpl = template.Must(template.New("schema-generate").Parse(
	`// Code generated by schema-generate. DO NOT EDIT.

package {{.PackageName}}

import (
{{- range $path, $importName := .ImportPaths }}
	{{ $importName }}"{{ $path }}"
{{- end }}
)

`))

var mainTmpl = template.Must(template.New("schema-generate").Parse(
	`{{- with $top := . -}}

type commaTracker struct {
	stream *jsoniter.Stream
	started bool
}

func (t *commaTracker) More() {
	if t.started {
		t.stream.WriteMore()
	} else {
		t.started = true
	}
}

type isEmptyChecker interface {
	IsEmpty() bool
}

// IsEmpty reports whether v is zero struct
// Does not support cycle pointers for performance, so as json
func IsEmpty(v interface{}) bool {
	if i, ok := v.(isEmptyChecker); ok {
		return i.IsEmpty()
	}
	rv := {{ .Pkg "reflect" }}.ValueOf(v)
	return !rv.IsValid() || rv.IsZero()
}

// DataType is a json data type
type DataType = int

const (
	// EmptyType is for empty values
	EmptyType DataType = iota
	// NullType is for 'null' values
	NullType
	// StringType is for 'string' values
	StringType
	// NumberType is for 'number' values
	NumberType
	// BoolType is for 'bool' values
	BoolType
)

// DataTypeToString ...
func DataTypeToString(t DataType) string {
	switch t {
	case EmptyType:
		return "EmptyType"
	case NullType:
		return "NullType"
	case StringType:
		return "StringType"
	case NumberType:
		return "NumberType"
	default:
		return {{.Pkg "fmt"}}.Sprintf("%d.(DataType)", int(t))
	}
}

var (
	jsonNullValue = []byte("null")
)

// OneOfStringNull is a 'string' or a 'null', and can be emptied
type OneOfStringNull struct {
	currentType DataType
	stringValue string
}

// NewOneOfStringNull creates a empty OneOfStringNull
func NewOneOfStringNull() OneOfStringNull {
	return OneOfStringNull{EmptyType, ""}
}

// NewOneOfStringNullString creates a OneOfStringNull of type string
func NewOneOfStringNullString(value string) OneOfStringNull {
	return OneOfStringNull{StringType, value}
}

// NewOneOfStringNullNull creates a OneOfStringNull of type null
func NewOneOfStringNullNull() OneOfStringNull {
	return OneOfStringNull{NullType, ""}
}

// IsEmpty returns true if the value is empty
func (value *OneOfStringNull) IsEmpty() bool {
	return value.currentType == EmptyType
}

// IsNull returns true if the value is 'null'
func (value *OneOfStringNull) IsNull() bool {
	return value.currentType == NullType
}

// IsString returns true if the value is a string
func (value *OneOfStringNull) IsString() bool {
	return value.currentType == StringType
}

// StringValue returns the current value if IsString() is true, "" otherwise
func (value *OneOfStringNull) StringValue() string {
	if value.currentType == StringType {
		return value.stringValue
	}
	return ""
}

// NullString returns the current value as a sql.NullString
func (value *OneOfStringNull) NullString() {{ .Pkg "database/sql" }}.NullString {
	return sql.NullString{
		Valid:  value.currentType == StringType,
		String: value.stringValue,
	}
}

// MarshalJSONStream serializes to a jsoniter Stream
func (value OneOfStringNull) MarshalJSONStream(stream *{{ .Pkg "jsoniter" "github.com/json-iterator/go" }}.Stream) {
	if value.currentType == StringType {
		stream.WriteString(value.stringValue)
	} else {
		stream.WriteNil()
	}
}

// MarshalJSON serialize to json
func (value OneOfStringNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case EmptyType:
		return jsonNullValue, nil
	case NullType:
		return jsonNullValue, nil
	case StringType:
		return jsoniter.Marshal(value.stringValue)
	}
	return nil, fmt.Errorf(
		"OneOfStringNull unsupported type: %s",
		DataTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfStringNull from json
func (value *OneOfStringNull) UnmarshalJSON(data []byte) error {
	if {{ .Pkg "bytes" }}.Equal(data, jsonNullValue) {
		value.currentType = NullType
	} else {
		if err := jsoniter.Unmarshal(data, &value.stringValue); err != nil {
			return err
		}
		value.currentType = StringType
	}
	return nil
}

// OneOfNumberNull is a 'string' or a 'null', and can be emptied
type OneOfNumberNull struct {
	currentType DataType
	numberValue float64
}

// NewOneOfNumberNull creates a empty OneOfNumberNull
func NewOneOfNumberNull() OneOfNumberNull {
	return OneOfNumberNull{EmptyType, 0}
}

// NewOneOfNumberNullNumber creates a OneOfNumberNull of type number
func NewOneOfNumberNullNumber(value float64) OneOfNumberNull {
	return OneOfNumberNull{NumberType, value}
}

// NewOneOfNumberNullNull creates a OneOfNumberNull of type null
func NewOneOfNumberNullNull() OneOfNumberNull {
	return OneOfNumberNull{NullType, 0}
}

// IsEmpty returns true if the value is empty
func (value *OneOfNumberNull) IsEmpty() bool {
	return value.currentType == EmptyType
}

// IsNull returns true if the value is 'null'
func (value *OneOfNumberNull) IsNull() bool {
	return value.currentType == NullType
}

// IsNumber returns true if the value is a number
func (value *OneOfNumberNull) IsNumber() bool {
	return value.currentType == NumberType
}

// NumberValue returns the current value if IsNumber() is true, 0 otherwise
func (value *OneOfNumberNull) NumberValue() float64 {
	if value.currentType == NumberType {
		return value.numberValue
	}
	return 0
}

// MarshalJSON serialize to json
func (value OneOfNumberNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case EmptyType:
		return jsonNullValue, nil
	case NullType:
		return jsonNullValue, nil
	case NumberType:
		return jsoniter.Marshal(value.numberValue)
	}
	return nil, fmt.Errorf(
		"OneOfNumberNull unsupported type: %s",
		DataTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfNumberNull from json
func (value *OneOfNumberNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = NullType
	} else {
		if err := jsoniter.Unmarshal(data, &value.numberValue); err != nil {
			return err
		}
		value.currentType = NumberType
	}
	return nil
}

// OneOfBoolNull is a 'bool' or a 'null', and can be emptied
type OneOfBoolNull struct {
	currentType DataType
	boolValue   bool
}

// NewOneOfBoolNull creates a empty OneOfBoolNull
func NewOneOfBoolNull() OneOfBoolNull {
	return OneOfBoolNull{EmptyType, false}
}

// NewOneOfBoolNullBool creates a OneOfBoolNull of type number
func NewOneOfBoolNullBool(value bool) OneOfBoolNull {
	return OneOfBoolNull{BoolType, value}
}

// NewOneOfBoolNullNull creates a OneOfBoolNull of type null
func NewOneOfBoolNullNull() OneOfBoolNull {
	return OneOfBoolNull{NullType, false}
}

// IsEmpty returns true if the value is empty
func (value *OneOfBoolNull) IsEmpty() bool {
	return value.currentType == EmptyType
}

// IsNull returns true if the value is 'null'
func (value *OneOfBoolNull) IsNull() bool {
	return value.currentType == NullType
}

// IsBool returns true if the value is a bool
func (value *OneOfBoolNull) IsBool() bool {
	return value.currentType == BoolType
}

// BoolValue returns the current value if IsBool() is true, false otherwise
func (value *OneOfBoolNull) BoolValue() bool {
	if value.currentType == BoolType {
		return value.boolValue
	}
	return false
}

// MarshalJSON serialize to json
func (value OneOfBoolNull) MarshalJSON() ([]byte, error) {
	switch value.currentType {
	case EmptyType:
		return jsonNullValue, nil
	case NullType:
		return jsonNullValue, nil
	case BoolType:
		return jsoniter.Marshal(value.boolValue)
	}
	return nil, fmt.Errorf(
		"OneOfBoolNull unsupported type: %s",
		DataTypeToString(value.currentType))
}

// UnmarshalJSON unserialize a OneOfBoolNull from json
func (value *OneOfBoolNull) UnmarshalJSON(data []byte) error {
	if bytes.Equal(data, jsonNullValue) {
		value.currentType = NullType
	} else {
		if err := jsoniter.Unmarshal(data, &value.boolValue); err != nil {
			return err
		}
		value.currentType = BoolType
	}
	return nil
}

{{- range .Aliases }}

// {{ .Name }} ...
type {{ .Name }} {{ .Type }}
{{- end -}}

{{- range .Structs }}

// {{ $top.Comment .Name .Description }}
type {{ .Name }} struct {
	{{- range .Fields }}
	// {{ $top.Comment .Name .Description }}
	{{ .Name }} {{ .Type }} {{ $top.Backquote }}json:"{{ .JSONName }}{{ if not .Required }},omitempty{{ end }}"{{ $top.Backquote }}
	{{ end -}}
}
{{- end -}}

{{- range $struct := .Structs }}
{{ if .GenerateCode }}

// MarshalJSON serializes to JSON
func (s *{{ .Name }}) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	stream := jsoniter.ConfigDefault.BorrowStream(buf)
	s.MarshalJSONStream(stream)
	stream.Flush()
	err := stream.Error
	jsoniter.ConfigDefault.ReturnStream(stream)

	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

func (s {{ .Name }}) MarshalJSONStream(stream *jsoniter.Stream) {
	{{- if .NoProp }}
	stream.WriteEmptyObject()
	{{- else }}
	stream.WriteObjectStart()
	ct := commaTracker{stream:stream}

	{{- range .Fields }}
	{{- if ne .JSONName "-" }}

	// Marshal the {{ .Name }} field
	{{- if and .Required .IsPointer }}

	// {{ .Name }} is required
	if s.{{ .Name }} == nil {
		stream.Error = {{ $top.Pkg "errors" }}.New("{{ .Name }} ({{ .JSONName }}) is a required")
		return
	}
	{{- end }}
	{{- if not .Required }}
	if !IsEmpty(s.{{ .Name }}) {
	{{- end }}
	ct.More()
	stream.WriteObjectField("{{ .JSONName }}")
	{{- if eq .Type "string" }}
	stream.WriteString(s.{{ .Name }})
	{{- else if eq .Type "OneOfStringNull" }}
	s.{{ .Name }}.MarshalJSONStream(stream)
	{{- else }}
	stream.WriteVal(s.{{ .Name }})
	if stream.Error != nil {
		return
	}
	{{- end }}
	{{- if not .Required }}
	}
	{{- end}}

	{{- end}}
	{{- end}}
	{{- if and .AdditionalType (ne .AdditionalType "false")}}
	for key, value := range s.AdditionalProperties {
		ct.More()
		stream.WriteObjectField(key)
		stream.WriteVal(value)
	}
	{{- end}}
	stream.WriteObjectEnd()
	{{- end}}
}

func (s *{{ .Name }}) UnmarshalJSON(data []byte) error {
	iter := jsoniter.ConfigDefault.BorrowIterator(data)
	s.UnmarshalJSONIterator(iter)
	err := iter.Error
	jsoniter.ConfigDefault.ReturnIterator(iter)
	return err
}

func (s *{{ .Name }}) UnmarshalJSONIterator(iter *jsoniter.Iterator) {
	{{- range .Fields }}
	{{- if .Required}}
	{{ .Name }}Received := false
	{{- end}}
	{{- end}}

	for field := iter.ReadObject(); field != ""; field = iter.ReadObject() {
		switch field {
		{{- range .Fields }}
		{{- if ne .JSONName "-" }}
		case "{{ .JSONName }}":
			{{- if ne .Type "bool" }}
			if iter.WhatIsNext() == jsoniter.BoolValue {
				if iter.ReadBool() {
					iter.ReportError("reading field {{ .JSONName }}", "{{ .JSONName }} is 'true', but the expected type is {{ .Type }}")
					return
				}
				// received 'false', which we accept and ignore for now
				// TODO make this a non-default option
			}
			{{- end}}
			{{- if eq .Type "string" }}
			s.{{ .Name }} = iter.ReadString()
			{{- else if eq .Type "bool" }}
			s.{{ .Name }} = iter.ReadBool()
			{{ else }}
			iter.ReadVal(&s.{{ .Name }})
			{{- end}}
			if iter.Error != nil {
				return
			}
			{{- if .Required}}
			{{ .Name }}Received = true
			{{- end}}
		{{- end}}
		{{- end}}
		default:
			{{- if eq .AdditionalType "false" }}
			iter.ReportError("reading {{ .Name }}", "additional property not allowed: \"" + field + "\"")
			return
			{{- else if .AdditionalType }}
            if s.AdditionalProperties == nil {
                s.AdditionalProperties = make(map[string]{{ .AdditionalType }}, 0)
            }
            var additionalValue {{ .AdditionalType }}
			iter.ReadVal(&additionalValue)
			if iter.Error != nil {
				return
			}
            s.AdditionalProperties[field]= additionalValue
			{{- else }}
			// Ignore the additional property
			{{- end }}
		}
	}

	{{- range .Fields }}
	{{- if .Required}}

	if !{{ .Name }}Received {
		iter.ReportError("validating {{ $struct.Name }}", "\"{{ .JSONName }}\" is required but was not present")
	}
	{{- end}}
	{{- end}}
}

{{- end -}}
{{- end -}}
{{- end -}}
`))
